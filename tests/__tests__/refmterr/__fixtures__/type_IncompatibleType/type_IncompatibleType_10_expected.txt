# Unformatted Error Output:
# File "tests/__tests__/refmterr/__fixtures__/type_IncompatibleType/type_IncompatibleType_10.ml", line 8, characters 27-28:
# Error: This expression has type $Cons_'b hlist
#        but an expression was expected of type 'a
#        The type constructor $Cons_'b would escape its scope


 ERROR  tests/__tests__/refmterr/__fixtures__/type_IncompatibleType/type_IncompatibleType_10.ml:8 27-28 

5 ┆ 
6 ┆ let rec len (type a) (l: a hlist): int = match l with
7 ┆   | Nil -> 0
8 ┆   | Cons (h, t) -> 1 + len t


This allows type thereExistsAType_Cons_'b to "escape" its scope.


  This type: hlist(thereExistsAType_Cons_'b)
  Expecting: 'a

Learn: What does it mean for a type variable to "escape" its scope?
Important assumptions about the type are potentially being violated because
values of that type are being passed outside the region ("escaping").
The error you see is likely preventing a runtime error.

These types that aren't allowed to escape are introduced when using GADTs or
locally abstract types (when you see functions defined in these forms):

  let myFunction : type a . a => a = ...
  let myFunction = (type a, x: a) => ...

If the names of these types are weird, then they're probably not ones defined
in locally abstract types, but generated by type inference when using GADTs

Some things that might solve the problem:
- Avoid passing these values outside this local region
- Wrap the value in a GADT making the escaping type "existential".
- Annotate the function it escapes to with locally abstract to match your function.
- Make sure locally abstract type annotations are polymorphic. They aren't by default.


